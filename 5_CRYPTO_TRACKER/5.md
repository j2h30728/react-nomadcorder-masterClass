# 5. CRYPTO TRACKER

### 데이터 Fetching

react-query : 편리한 방식으로 데이터를 fetching 시킬 수 있음
: 왜 reaxt-query가 만들어 졌으며, 어떤 문제를 해결할 수 있는가?

## 5.0. Setup

1. typescript react
   ` npx create-react-app 5_0 --template typescript`
2. react-router-dom : 어플리케이션에서 URL을 가질 수 있도록 해줌. 기본적으로 각기다른 화면을 가지게 함
   `npm i react-router-dom@5.3.0`
   `npm i --save-dev @types/react-router-dom`
3. styled-components
   `npm install styled-components`
   `npm install --save-dev @types/styled-components`

두 화면

1. '/' :Home 모든 코인이 보임
2. '/:id' : 코인 아이디에 맞춰서 코인이 들어감
   - /btc => Coin detail 코인 상세정보를 보여줌

#### Nested Router

한 스크린 내에 또다른 Router를 가질 수 있음
ex)
/btc/information
/btc/chart

`import { BrowserRouter } from "react-router-dom";`
: 타이스크립트가 react-router-dom이 무엇인지 알지 못함
"모듈 'react-router-dom'에 대한 선언 파일을 찾을 수 없습니다. "
DefinitelyTyped 설치 필요

```
해당 항목이 있는 경우
'npm i --save-dev @types/react-router-dom'을(를) 시도하거나,
'declare module 'react-router-dom';'을(를) 포함하는 새 선언(.d.ts) 파일 추가
```

=> `npm i --save-dev @types/react-router-dom`

`<Route path="/:conId">` : Router에게 RUL이 변수값을 가지며, RUL의 이 부분의 값에 관심이 있다고 말하는 방식

## 5.1. Styles

태그들은 기본적으로 스타일을 가지고 있다.
: `<li>` 는 padding이 설정된 리스트임.

#### Reset CSS

1. 모든 HTML태그들을 가져다가 직접 margin:0, padding:0, border:0으로 돌려놓음
2. styled-reset을 사용
   styled-reset을 import 해서 컴포넌트(Reset)을 사용하기만 하면됨

```jsx
import {Reset} from 'styled-reset'

const App () => (
   <React.Fregment>
      <Reset />
      <div>Hi, I'm an app!</div>
   </React.Fregment>)
```

#### Google Fonts

https://fonts.google.com

- Source Sans Pro 폰트
  `<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@300;400;700&display=swap" rel="stylesheet" />`

#### Flat UI Color

https://flatuicolors.com/palette/gb

```tsx
export const theme: DefaultTheme = {
  bgColor: "#f5f6fa",
  textColor: "#2f3640",
  accentColor: "#44bd32",
};
```

#### createGlobalStyle

매번 스타일 컴포넌트를 만들 때 스타일 컴포넌트는 고립되었음. == CSS 범위가 제한되었다는 의미.
createGlobalSTyled로 만든 컴포넌트가 렌더링 될때, 전역 스코프에 스타일들을 알려주어 고립되지않고 global이 됨.

- https://github.com/zacanger/styled-reset/blob/master/src/index.ts

```tsx
import { createGlobalStyle } from "styled-components";
import { Outlet } from "react-router-dom";

function App() {
  return (
    <>
      <GlobalStyle />
      <Outlet />
    </>
  );
}
const GlobalStyle = createGlobalStyle`
   전역으로 지정할 css 내용추가
`;
```

#### GlobalStyle 내에서 Theme 적용 가능

- index.tsx에서 theme을 적용
- App.tsx에서 전역 CSS적용
- index.tsx > Router.tsx > App.tsx 이기 때문에
  App.tsx에서 정의되는 GlobalStyle 내에서 `${props => props.theme.bgColor}`을 이용하여 theme을 사용할 수 있음

## 5.2. Home Part One

- Link 의 to : router를 사용. 새로고침을 하지 않음.
- a 의 href : 페이지가 새로고침됨

- `height: 15vh` === viewport hight(vh) 10 %
- `a 태그의 padding`
  - Link태그에 적용해야지 박스에 진입했을대 어느 곳을 클릭해도 이동이 됨.
  - 만약, li태그에 padding을 적용하면 a태그의 글자영역을 직접 클릭해야함
- `a 태그의 display`
  - 카드의 글자 뿐만 아니라, 글씨 바깥인 박스 테두리내 모든곳 클릭 시 이동 가능

```tsx
const CoinList = styled.ul``;
const Coin = styled.li`
  background-color: ${props => props.theme.darkBgColor};
  color: ${props => props.theme.textColor};
  border-radius: 15px;
  margin-bottom: 10px;
  a {
    padding: 20px;
    transition: color 0.2s ease-in;
    display: block;
  }
  &:hover {
    a {
      color: ${props => props.theme.accentColor};
    }
  }
`;
```

## 5.3. Home part Two

`&rarr;` : 오른쪽 화살표(right arrow)

화면을 크게 했을 때도, 모바일 화면처럼 가운데에 위치하게 됨

```tsx
const Container = styled.div`
  padding: 0px 20px;
  max-width: 480px;
  margin: 0 auto;
`;
```

typescript에게 데이터가 어떻게 생겼는지 알려줘야함 => interface 생성
즉, 데이터가 API에서 가져오는 것일 때도 똑같이 typescript에게 뭐가 오는 것인지 알려줘야함

### 즉시 실행 함수

function 을 만들고 바로 console.log 1을 찍을 수 있음
아래의 함수가 선언과 동시에 바로 실행이 됨

```tsx
(() => console.log(1))();

(async()=>{ ... })()
```

## 5.4. Route States

Coins -> Coin
: 보이지 않는 방식으로(비하인드더씬) 데이터를 어떻게 보내는가
화면 이동할 때 데이터를 보내는 것은 parameter를 이용해 URL에게 코인에 대한 정보를 넘기는 것
=> 한 화면에서 다른 화면으로 정보를 받아올 수 있음

방법

1. URL : parameter
2. state : 비하인드 더 씬 소통

#### useLocation사용

- react router DOM이 보내주는 Location object에 접근함
- 직접 API를 부르지않고 화면에 데이터를 보여줌
- <Link> 태그를 통해 state를 전달받아 구현되는 화면이기때문에 시크릿모드를 통해 URL을 이용해 다이렉트로 접속하면 state가 없다고 오류가뜸

```tsx
export default function Coin() {
  const [loading, setLoading] = useState(true);
  const { state } = useLocation() as RouterState;
  return (
    <Container>
      <Header>
        <Title>코인 {state.name}</Title>
      </Header>
      {loading ? <Loader>Loading...</Loader> : null}
    </Container>
  );
}
```

- 아래의 코드를 추가해주어 URL로 접근시에 Loading... 화면 띄워줌
- URL로 접근 : Link 태그에서 전달해주는 state가 존재하지않음. useLocation의 반환값이 없음. 그러므로 `state.?name === undefined`

```tsx
<Title>{state?.name || "Loading..."}</Title>
```

## 5.5. Coin Data

```tsx
//아래의 두 코드는 동일함

//1.
async () => {
  const response = await fetch(
    `https://api.coinpaprika.com/v1/coins/${coinId}`
  );
  const json = await response.json();
};

//2. 축약 버전
const coinResponse = await(
  await fetch(`https://api.coinpaprika.com/v1/coins/${coinId}`)
).json();
```

- typescript는 info와 priceInfo가 항상 빈 object라고 생각함
- 그러므로 아래의 `info.hello`에서 hello에 에러를 띄워줌(info는 빈객체다! 라고)
- typescript에게 일일이 api에서 오는 값들을 알려줘야함(자동으로 알려주는 방법도 있다고함)

```tsx

  const [info, setInfo] = useState({});
  const [priceInfo, setPriceInfo] = useState({});

  ...

  <span>{info.hello}</spna>

```

## 5.6. Data Types

## 5.7. Nested Routes part One

Nested router로 react router 기능 사용

```tsx
useEffect(() => {
  //즉시실행 함수. 추후에 react - qeury 로 변경 예정
  (async () => {
    //1. 코인에 대한 정보 2. 코인의 가격 정보
    const infoData = await (
      await fetch(`https://api.coinpaprika.com/v1/coins/${coinId}`)
    ).json();
    const priceData = await (
      await fetch(`https://api.coinpaprika.com/v1/tickers/${coinId}`)
    ).json();
    setInfo(infoData);
    setPriceInfo(priceData);
    setLoading(false);
  })();
}, []); // 여기 부분
```

React Hook useEffect has a missing dependency: 'coinId'. Either include it or remove the dependency array.
: useEffect가 coinID의 의존성을 잃어 버렸다.

처음 렌더될때 한 번만 실행시키고 싶다 : No dependecy `useEffect(()=>{}, [])`
hook의 최선의 성능을 위해서는 dependecy를 넣는 것이 좋다고 함 : coinId

- 현재 coinId는 component의 일생내내 변하지않기 때문에 `useEffect(()=>{}, [coinId])`로 작성하는 것에 문제 없음

## 5.8. Nested Routes part Two

#### useMatch (useRouteMatch)

`useMatch('url')`의 인자로 url을 넘기면,
: 해당 url과 일치할 경우 url의 정보를 반환
일치하지 않을 경우 null을 반환

- useMatch : v6
- useRouteMatch v5

`useMatch('/:coinId/price')` : useMatch에게 우리가 coinId/price 라는 URL에 있는지 확인해달라 하는 것

```tsx
//useMatch('/:coinId')

//http://localhost:3000/eth-ethereum
{params: {coinId :"eth-ethereum"},
pathname: '/eth-ethereum',
pathnameBase: '/eth-ethereum',
pattern: {caseSensitive:false, end:true, path :"/:coinId"}}

```

```tsx
//http://localhost:3000/eth-ethereum/price
const test = useMatch("/:coinId/price");
console.log('useMatch("/:coinId/price")', test); // 값 반환
console.log('useMatch("/:coinId/chart")', test); //null
```

## 5.9. React Query part One

```tsx
const queryClient = new QueryClient();

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <RouterProvider router={router} />
      </ThemeProvider>
    </QueryClientProvider>
  </React.StrictMode>
);
```

- `<ThemeProvider theme={theme}>` : themeProvider 안에 있는 모든 것이 theme으로 접근 할 수있음

- `<QueryClientProvider client={queryClient}>` : QueryClientProvider 안에 있는 모든 것이 queryClient로 접근 할 수 있음
  => 리액트 쿼리를 설치한 것과 같음

기본적으로 API와 관련된 것은 component들과 멀리 떨어뜨림

#### react-query 사용하기

1. fetcher 함수 만들기

- fetcher 함수 :
  - 기본적으로 fetch를 하는 함수
  - 꼭 fetch promise 를 return 해줘야함
    ex) fetcher 함수 예시
  ```tsx
  const fetchCoins = await(
    await fetch(`https://api.coinpaprika.com/v1/coins/`)
  ).json();
  ``;
  ```
- fetcher 함수에서 fetchCoins URL을 부르고(== API를 호출) => URL으로부터 Json를 return함

2. hook 사용

- `const {isLoading, data} = useQuery(["queryKey"], fetacher함수)`
  : queyrKey - query의 고유 식별자

  - ex) useQuery(['allCoins', fetchCoins])
  - 반환 값 :
    - isLoading(Boolean) :
      - useQuery라는 HOok이 fetcher함수 fetchCoins를 불러오고, fetcher함수가 끝나면 react query 가 말해줌
      - fetcher 함수가 끝나면 false, 로딩중이면 true
    - data(json) :
      - fetchCoins가 끝나면 react query는 함수의 데이터를 data에 넣어줌

- Coins 페이지
  -> coin 선택하여 페이지 이동
  -> 다시 Coins 페이지 이동할때
  useQuery 를 사용할 경우, 로딩컴포넌트가 나오지않고 Coins 컴포넌트가 렌더링됨
  - react query 가 데이터를 캐시에 저장해두기 때문임
  - react query는 데이터를 파괴하지 않음. 데이터를 유지시킴.

## 5.10. React Query part Two

- coin 페이지 이동시 loading 이 계속적으로 렌더링됨
  - fetch함수를 계속 불러옴
- coins 페이지 이동시 loading 이 렌더링 되지않음
  - react query가 캐시에 있는 데이터를 전달해 주기 때문

#### react-query devtools

- 캐시에 존재하는 query를 볼수 있음
  `$ npm i @tanstack/react-query-devtools`
- [tanstack react query - devtools 링크](https://tanstack.com/query/v4/docs/react/devtools)

  ```tsx
  import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

  function App() {
    return (
      <QueryClientProvider client={queryClient}>
        {/* The rest of your application */}
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    );
  }
  ```

- render 할 수 있는 component
- react query에 있는 devtools를 import 해오면 캐시에 있는 query를 볼 수 있음
- Router아래에서 Devtools(ReactQueryDevtools)를 render함
- **trigger**
  - **refetch** : 데이터를 다시 refetch
  - **reset** : 쿼리를 reset 할 수도 있음
    - reset을 누르면 loading 컴포넌트가 작동하는 것을 확인할 수 있음
- **query key** : React query가 query를 인식하는 방법
  - 각각 다른 key로 할당해줘야함
  - react query는 key를 array로 감싸서 표현하고 있음
- react query가 query를 array로 보고 있음

  ```ts
  //api.ts
  const BASE_URL = `https://api.coinpaprika.com/v1`;
  export async function fetchCoins() {
    return (await fetch(`${BASE_URL}/coins`)).json();
  }
  export async function fetchCoinInfo(coinId: string | undefined) {
    return (await fetch(`${BASE_URL}/coins/${coinId}`)).json();
  }
  export async function fetchCoinTrikers(coinId: string | undefined) {
    return (await fetch(`${BASE_URL}/tickers/${coinId}`)).json();
  }
  ```

  ```tsx
  //coin.tsx

  //동일한 이름으로 가져오기 때문에 새로 이름을 할당 해 줌
  const { isLoading: infoLoading, data: infoData } = useQuery<InfoData>(
    ["info", coinId],
    () => fetchCoinInfo(coinId)
    //fetchCoinInfo함수를 불러와서 URL로부터 오는 coinId를 넣어주는 것
  );
  const { isLoading: trikersoading, data: trikersData } = useQuery<TrikersData>(
    ["trikers", coinId],
    () => fetchCoinTrikers(coinId)
  );
  ```

## 5.11. Recap

1. react query는 fetcher함수를 만들 수 있게 해줌
   - 기본적으로 fetcher함수와 연결시켜서 isLoading같은 함수가 불렸는지 아닌지를 알려줌
   - 함수가 끝났을 때는 결과 값을 data에 넣어줘서 쉽게 접근할 수 있게 해줌
2. 강력한 Caching(캐싱) 매커니즘을 갖고 있음
   - 만약 query의 고유한 key값을 react query에 넘겨 주었다면, react query는 유저에게 Loading을 다시 보여주지 않음.
     = react query는 이미 캐시에 어떤한 데이터가 있다는 것을 알고 있기 때문
3. React query devTools
   - 캐시에 어떤 query가 있는지 보여줌
     - query(쿼라) : 데이터베이스에게 특정 데이터를 보여달라는 클라이언트의 요청
   - 결과를 보여줌
   - data explorer도 보여줌

- argument가 필요한 fetcher 함수 : 익명함수를 하나 만들어서 fetcher함수 불러 return 해줌
  - ex) `useQuery([queryKey],() => fetcherCoinTrickers(argument))`
- argument가 필요하지 않는 fetcher함수 : 함수 이름만 작성
  - ex) `useQuery([querykey],fetcherCoinTrickers)`

4. queryKey : key는 react query 캐시 시스템에서 저장되고 작동하기 위해서는 고유한 값이어야 함

- array를 만들어서,
  첫번째 key : 카테고리 역할
  두번째 key : URL에 있는 coinId 가 됨 == 고유한 부분
- 2가지 query를 가지고 있음(fetchCoinInfo, fetcherCoinTrickers )
  => useQuery 의 return 값이 같음 (isLoading, data)
  => 2개의 query 이기 때문에 이름을 바꿨음 (`isLoading: infoLoading, data: infoData`)
  : 2개의 query에 각각 고유한 id를 주고, 함수로부터 return property를 받아와서 이름을 바꿈

## 5.12. Price Chart

### [useOutletContext](../4_REACT_ROUTER_V6/4.md#47-useoutletcontext)

부모 컴포넌트에서 모든 자식컴포넌트(Outlet 컴포넌트)와 공유하고 싶은 데이터가 있을때 사용
`<Outlet context={전달할 내용(object): {coinId:coinId}}/>`
`const 전달할 내용: {coinId} = useOutletContext()`

## 5.13. Price Chart part Two

`npm install --save react-apexcharts apexcharts`

#### (APEXCHARTS)[https://apexcharts.com/]

```tsx
import ApexChart from "react-apexcharts";

...

export default function Chart() {
  const { coinId } = useOutletContext<ChartProps>();
  const { isLoading, data } = useQuery<IHistorical[]>(["ohlcv", coinId], () =>
    fetchCoinHistory(coinId)
  );
  return (
    <div>
      {isLoading ? (
        "Loading chart..."
      ) : (
        <ApexChart
          type="line" // 그래프 타입 : 선 그래프
          series={[
            {
              name: "Price", // 값의 제목 : Price
              data: data?.map(price => parseFloat(price.close)) as number[], // 숫자로 변경후, 숫자를 담은 배열인 것으로 타입 선언
            },
          ]}
          options={{
            theme: {
              mode: "dark", // 다크모드
            },
            chart: {
              height: 300, // 그래프 위치
              width: 500, //그래프 두께
              toolbar: {
                show: false, // 오른쪽 상단의 툴바 숨김
              },
            },
            stroke: {
              curve: "smooth", // 그래프 곡선도 : 부드럽게
            },
            title: {
              text: coinId, // 그래프 제목 : coinId
              align: "center", //그래프 제목 위치 : 중앙정렬
            },
            grid: {
              show: false, // 그리드 숨김
            },
            xaxis: {
              labels: {
                show: false, // x축 숨김
              },
            },
            yaxis: {
              labels: {
                show: false, // y축 숨김
              },
            },
          }}
        />
      )}
    </div>
  );
}
```

## 5.14 Price Chart part Three

```tsx
<ApexChart

...

  options={{
    theme: {
      mode: "dark",
    },
    chart: {
      height: 300,
      width: 500,
      toolbar: {
        show: false,
      },
      background: "trnasparse", // 배경 투명
    },

...

    xaxis: {
      axisBorder: { show: false },
      axisTicks: { show: false },
      labels: {
        show: false,
      },
      type: "datetime", // 12 Jan형식으로 표기됨
      categories: data?.map(price =>
        new Date(price.time_close * 1000).toISOString() // 초단위 => UTC 형태 값으로 변경(ISO 형식(ISO 8601)의 문자열을 반환)
      ),
    },

..

    fill: { //그래프 색상
      type: "gradient", // 그라데이션
      gradient: {
        gradientToColors: ["navy"], //첫 시작 색상
        stops: [0, 100], // 0 :시작값 ~ 100 : 기본값
      },
    },
    colors: ["yellow"], // 기본값
    tooltip: { // 그래프값에 마우스 커서 hover할 경우
      y: {
        formatter: value => `$${value.toFixed(1)}`, //소숫점 1자리 까지만 표시
      },
    },
  }}
/>
```

## 5.15. Final Touches

#### useQuery hook 3번째 argument : 자동으로 refetch 시키기

1. 첫 번째 argument : 고유한 key 값
2. 두 번째 argument : fetcher 함수
3. 세 번째 argument : (optional) object - refetch interval을 miliseconds로 할 수 있음
   === query를 지정한 miliseconds 마다 refetch함
   - state 업데이트
   - UI 새로고침됨
   - 주기적으로 백그라운드에서 앱을 업데이트 할 수 있음

```tsx
const { isLoading: infoLoading, data: infoData } = useQuery<InfoData>(
  ["info", coinId],
  () => fetchCoinInfo(coinId),
  {
    refetchInterval: 5000,
    //5000ms(5초) : 해당하는 이 query를 5초마다 refresh함
  }
);
```

#### react helmet : 웹페이지 제목 바꾸기

[**react-helmet**](https://www.npmjs.com/package/react-helmet)

[github](https://github.com/nfl/react-helmet)
`npm install react-helmet`
`npm i --save-dev @types/react-helmet`

```tsx
import Helmet from "react-helmet";

<Helmet>
  <title>넣고싶은 타이틀 내용</title>
</Helmet>;
```

예시

```tsx
import Helmet from "react-helmet";
...

  return (
    <Container>
      <Helmet>
        <title>
          {state?.name ? state?.name : loading ? "Loading..." : infoData?.name}
          {/* 비트코인 이름이 있을 경우, 이름 표시하고 없다면 Loading... 표시함 */}
        </title>
      </Helmet>

...

```

- react hemlet은 head로 가는 direct link
- 비교적 수월하게 헤더정보를 관리할 수 있음
- Supports all valid head tags: title, base, meta, link, script, noscript, and style tags.
  - 화면 이동에 따라 타이틀 변경 가능 : title 변경
- Supports attributes for body, html and title tags.
- Supports server-side rendering.
- Nested components override duplicate head changes.
- Duplicate head changes are preserved when specified in the same component (support for tags like "apple-touch-icon").
- Callback for tracking DOM changes.
  - DOM API를 사용해서 직접 헤더를 변경하는 방식([참고](https://github.com/nfl/react-helmet/blob/master/src/HelmetUtils.js#L372))

## 16.
